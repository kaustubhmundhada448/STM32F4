/*
-------------------------------------------------------SAMPLE PROGRAM ------------------------------------------------
#include "stm32f4xx_MPU6050.h"
#include "stm32f4xx_conf.h"
volatile uint8_t mpuInterrupt = 0,dmpReady = 0;
uint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU
uint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)
uint16_t packetSize;    // expected DMP packet size (default is 42 bytes)
uint16_t fifoCount;     // count of all bytes currently in FIFO
uint8_t fifoBuffer[64];
int32_t q[4];

void EXTI15_10_IRQHandler()
{
    if(EXTI_GetITStatus(EXTI_Line10) != RESET)
        {
        mpuInterrupt = 1;
        EXTI_ClearITPendingBit(EXTI_Line10);
        }
}


int main()
{
    MPU6050_Initialize();
    Init_led();

    devStatus = MPU6050_dmpInitialize();
    MPU6050_setXGyroOffset(220);
    MPU6050_setYGyroOffset(76);
    MPU6050_setZGyroOffset(-85);
    MPU6050_setZAccelOffset(1788);

    if (devStatus == 0)
    {
        MPU6050_setDMPEnabled(1);
        MPU6050_External_Interrupt_Init();
        mpuIntStatus = MPU6050_getIntStatus();
        dmpReady = 1;
        packetSize = MPU6050_dmpGetFIFOPacketSize();
    }
    else
    {
    }
    GPIO_ResetBits(GPIOD,GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);

    while(1)
    {
        if (!dmpReady) return(0);
        while (!mpuInterrupt && fifoCount < packetSize);

        mpuInterrupt = 0;
        GPIO_ToggleBits(GPIOD,GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);

        mpuIntStatus = MPU6050_getIntStatus();
        fifoCount = MPU6050_getFIFOCount();
        if ((mpuIntStatus & 0x10) || fifoCount == 1024)
        {
            MPU6050_resetFIFO();
        }
        else if (mpuIntStatus & 0x02)
        {
            while (fifoCount < packetSize) fifoCount = MPU6050_getFIFOCount();
            MPU6050_getFIFOBytes(fifoBuffer, packetSize);
            fifoCount -= packetSize;
            MPU6050_dmpGetQuaternion(q, fifoBuffer);
        }
    }
}

 */
#include "stm32f4xx_MPU6050.h"
#include "stm32f4xx_conf.h"
#include "stm32f4xx.h"
#include "core_cm4.h"

uint8_t I2C1_SLAVE_ADDRESS;
uint8_t a[42],buffer[42],dmpPacketSize = 0;
uint8_t *dmpPacketBuffer = &a[0];
uint32_t k;
const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] = {
    // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

// thanks to Noah Zerkin for piecing this stuff together!
const unsigned char dmpConfig[MPU6050_DMP_CONFIG_SIZE] = {
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         // FCFG_1 inv_set_gyro_calibration
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         // FCFG_3 inv_set_gyro_calibration
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   // D_0_104 inv_set_gyro_calibration
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   // D_0_24 inv_set_gyro_calibration
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // D_1_152 inv_set_accel_calibration
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         // FCFG_7 inv_set_accel_calibration
    0x00,   0x6C,   0x02,   0x20, 0x00,               // D_0_108 inv_set_accel_calibration
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_00 inv_set_compass_calibration
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_01
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_02
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_10
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_11
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_12
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_20
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_21
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_22
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   // D_1_236 inv_apply_endian_accel
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   // FCFG_5 inv_set_bias_update
    0x00,   0xA3,   0x01,   0x00,                     // D_0_163 inv_set_dead_zone
                 // SPECIAL 0x01 = enable interrupts
    0x00,   0x00,   0x00,   0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
    0x07,   0x86,   0x01,   0xFE,                     // CFG_6 inv_set_fifo_interupt
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
    0x07,   0x7E,   0x01,   0x30,                     // CFG_16 inv_set_footer
    0x07,   0x46,   0x01,   0x9A,                     // CFG_GYRO_SOURCE inv_send_gyro
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_9 inv_send_gyro -> inv_construct3_fifo
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_12 inv_send_accel -> inv_construct3_fifo
    0x02,   0x16,   0x02,   0x00, 0x01                // D_0_22 inv_set_fifo_rate

    // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
    // 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
    // DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

    // It is important to make sure the host processor can keep up with reading and processing
    // the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};

const unsigned char dmpUpdates[MPU6050_DMP_UPDATES_SIZE] = {
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};

#define I2C1_SLAVE_ADDRESS 0b1101000
#define devAddr 0b11010000
void delay(int i)
{
	long time;
	time = 100000*i;
	for( ; time > 0; time -- )
	{

	}
}

void Init_i2c(void)
	{
		 RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);                             	//Enable I2c clock
		 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB|RCC_AHB1Periph_GPIOD, ENABLE);       	//Enable gpio clock


		 GPIO_InitTypeDef GPIO_Init_Struct;													//Initialize all pins
		 GPIO_Init_Struct.GPIO_OType = GPIO_OType_OD;                                     	//SCLK and SDA must be open drain
		 GPIO_Init_Struct.GPIO_PuPd = GPIO_PuPd_UP;
		 GPIO_Init_Struct.GPIO_Mode = GPIO_Mode_AF;
		 GPIO_Init_Struct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
		 GPIO_Init_Struct.GPIO_Speed = GPIO_Speed_50MHz;                                  	//Must be greater than a particular value
		 GPIO_Init(GPIOB, &GPIO_Init_Struct);
		 GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);                          	//Connecting those terminals to AF config
		 GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_I2C1);							//Connecting those terminals to AF config


		 I2C_InitTypeDef I2C_Init_Struct;													//Initialize i2c
		 I2C_Init_Struct.I2C_ClockSpeed = 400000;											//400 kHz (max for i2c)
		 I2C_Init_Struct.I2C_Mode = I2C_Mode_I2C;
		 I2C_Init_Struct.I2C_DutyCycle = I2C_DutyCycle_2;									//50% duty cycle standard
		 I2C_Init_Struct.I2C_OwnAddress1 = 0x00;											//own address doesnt matter if stm is master
		 I2C_Init_Struct.I2C_Ack = I2C_Ack_Disable;											//Acknowledgement is disabled by default can be enabled later
		 I2C_Init_Struct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;            //select according to the address format
		 I2C_Init(I2C1, &I2C_Init_Struct);
		 I2C_Cmd(I2C1,ENABLE);

	}

void Init_led(void)
	{

		GPIO_InitTypeDef GPIO_Init_Struct;
		GPIO_Init_Struct.GPIO_Pin = GPIO_Pin_15|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14;		//Initialize leds (self explainatory)
		GPIO_Init_Struct.GPIO_Mode = GPIO_Mode_OUT;
		GPIO_Init_Struct.GPIO_OType = GPIO_OType_PP;
		GPIO_Init_Struct.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_Init_Struct.GPIO_PuPd = GPIO_PuPd_NOPULL;
		GPIO_Init(GPIOD, &GPIO_Init_Struct);

	}

void Init_usart(void)
	{

		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);               				//enable clock
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);               				//enable clock

		GPIO_InitTypeDef GPIO_Init_Struct;                                            		//initialize pins
		GPIO_Init_Struct.GPIO_Pin = GPIO_Pin_2;
		GPIO_Init_Struct.GPIO_Mode = GPIO_Mode_AF;                                    		//using as usart
		GPIO_Init_Struct.GPIO_OType = GPIO_OType_PP;
		GPIO_Init_Struct.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_Init_Struct.GPIO_PuPd = GPIO_PuPd_UP;
		GPIO_Init(GPIOA, &GPIO_Init_Struct);
		GPIO_PinAFConfig(GPIOA,GPIO_PinSource2,GPIO_AF_USART2);


		USART_InitTypeDef USART_Init_Struct;
		USART_Init_Struct.USART_BaudRate = 38400;											//self explainatory
		USART_Init_Struct.USART_WordLength = USART_WordLength_8b;
		USART_Init_Struct.USART_StopBits = USART_StopBits_1;
		USART_Init_Struct.USART_Parity = USART_Parity_No;
		USART_Init_Struct.USART_Mode = USART_Mode_Tx;
		USART_Init_Struct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
		USART_Init(USART2,&USART_Init_Struct);
		USART_Cmd(USART2,ENABLE);         													//enable uart

	}

void Init_tim(void)
	{

		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);


		TIM_TimeBaseInitTypeDef TIM_Init_Struct;                                      		//initialize counter
		TIM_Init_Struct.TIM_Prescaler = 39;													//pescalar 40
		TIM_Init_Struct.TIM_CounterMode = TIM_CounterMode_Up;								//self expainatory
		TIM_Init_Struct.TIM_Period = 40000;													//period 40000 (later used to find out Time for one loop
		TIM_Init_Struct.TIM_ClockDivision = TIM_CKD_DIV1;
		TIM_Init_Struct.TIM_RepetitionCounter = 0x00;
		TIM_TimeBaseInit(TIM2,&TIM_Init_Struct);
		TIM_Cmd(TIM2,ENABLE);

	}

void Init_mpu(void)
	{
	uint8_t data = 0x01;
	//waking up imu mpu6050 from sleep and setting reference clock to x axis of gyroxcope by writting regester no 117 to 00000001
	TM_I2C_WriteMulti(I2C1, 0b11010000, 0x6B,&data,1);
	//setting gyro range to 250 deg per sec (which is default)
	TM_I2C_Write(I2C1, 0b11010000, 0x1B,0x00);
	}

uint8_t Rec_data (uint8_t reg)
	{

	return(TM_I2C_Read(I2C1, 0b11010000, reg));
	}

void Calibrate_Gyros(void)
	{
		int x = 0,k=0;
		int16_t GYRO_XOUT_Offset = 0;
		int16_t GYRO_YOUT_Offset = 0;
		int16_t GYRO_ZOUT_Offset = 0;
		uint8_t regadd,Data[6];

		for(x = 0; x<5000; x++)
			{
				regadd=0x43;																//address of the resistor containing latest sensor data
				for(k=0;k<6;k++)															//total six resister for gyroscope
					{
						Data[k]=Rec_data (regadd);
						regadd++;																//address of next resister
					}
																						//among 6 resisters
				GYRO_XOUT_Offset = ((Data[0]<<8)|Data[1]);									//1st two give divided value of actual 16 bit Data o/p of x axis sensor
				GYRO_YOUT_Offset = ((Data[2]<<8)|Data[3]);									//next two give divided value of actual 16 bit Data o/p of y axis sensor
				GYRO_ZOUT_Offset = ((Data[4]<<8)|Data[5]);									//next two give divided value of actual 16 bit Data o/p of z axis sensor
				Offset[0]+=GYRO_XOUT_Offset;
				Offset[1]+=GYRO_YOUT_Offset;												//adding all 5000 value
				Offset[2]+=GYRO_ZOUT_Offset;
			}
		Offset[0] /= 5000;
		Offset[1] /= 5000;																//dividing by 5000 for mean Offset
		Offset[2] /= 5000;
	}

void Calibrate_Accel(void)
	{
		int x = 0,k=0;
		int16_t GYRO_XOUT_Offset = 0;
		int16_t GYRO_YOUT_Offset = 0;
		int16_t GYRO_ZOUT_Offset = 0;
		uint8_t regadd,Data[6];

		for(x = 0; x<5000; x++)
			{
				regadd=0x3B;																//address of the resistor containing latest sensor data
				for(k=0;k<6;k++)															//total six resister for gyroscope
					{
						Data[k]=Rec_data (regadd);
						regadd++;																//address of next resister
					}
																						//among 6 resisters
				GYRO_XOUT_Offset = ((Data[0]<<8)|Data[1]);									//1st two give divided value of actual 16 bit Data o/p of x axis sensor
				GYRO_YOUT_Offset = ((Data[2]<<8)|Data[3]);									//next two give divided value of actual 16 bit Data o/p of y axis sensor
				GYRO_ZOUT_Offset = ((Data[4]<<8)|Data[5]);									//next two give divided value of actual 16 bit Data o/p of z axis sensor
				Offset_accel[0]+=GYRO_XOUT_Offset;
				Offset_accel[1]+=GYRO_YOUT_Offset;												//adding all 5000 value
				Offset_accel[2]+=GYRO_ZOUT_Offset;
			}
		Offset_accel[0] /= 5000;
		Offset_accel[1] /= 5000;																//dividing by 5000 for mean Offset
		Offset_accel[2] /= 5000;
	}

void Send_data_usart(int data)                                                      //function for sending some integer
	{

		while (!USART_GetFlagStatus(USART2, USART_FLAG_TC));
		USART_SendData(USART2,data);
		while (!USART_GetFlagStatus(USART2, USART_FLAG_TC));
		USART_SendData(USART2,data>>8);
		while (!USART_GetFlagStatus(USART2, USART_FLAG_TC));
		USART_SendData(USART2,data>>16);
		while (!USART_GetFlagStatus(USART2, USART_FLAG_TC));
		USART_SendData(USART2,data>>24);

	}

void MPU6050_External_Interrupt_Init()
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

	GPIO_InitTypeDef GPIO_C;
	GPIO_C.GPIO_Mode = GPIO_Mode_IN;
	GPIO_C.GPIO_Pin = GPIO_Pin_10;
	GPIO_C.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_C.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_C.GPIO_OType = GPIO_OType_PP;
	GPIO_Init(GPIOC,&GPIO_C);

	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOC,EXTI_PinSource10);

	EXTI_InitTypeDef EXTI_PC10;
	EXTI_PC10.EXTI_Line = EXTI_Line10;
	EXTI_PC10.EXTI_LineCmd = ENABLE;
	EXTI_PC10.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_PC10.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_Init(&EXTI_PC10);

	NVIC_InitTypeDef NVIC_PC10;
	NVIC_PC10.NVIC_IRQChannel =  EXTI15_10_IRQn;
	NVIC_PC10.NVIC_IRQChannelCmd = ENABLE;
	NVIC_PC10.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_PC10.NVIC_IRQChannelSubPriority = 0;
	NVIC_Init(&NVIC_PC10);
}

void MPU6050_Initialize(void)
{
	//Init_tim(); 								//Initialize timer
	Init_i2c();									//Initialize I2C
	Init_mpu();									//Initialize MPU-6050
}

void MPU6050_setMemoryBank(uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_BANK_SEL, bank);
}

void MPU6050_setMemoryStartAddress(uint8_t address) {
	TM_I2C_Write(I2C1,devAddr, MPU6050_RA_MEM_START_ADDR, address);
}

void MPU6050_setSlaveAddress(uint8_t num, uint8_t address) {
    if (num > 3) return;
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_I2C_SLV0_ADDR + num*3, address);
}

void MPU6050_setI2CMasterModeEnabled(uint8_t enabled) {
	TM_I2C_Write_Bit(I2C1,devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);
}

void MPU6050_resetI2CMaster() {
	TM_I2C_Write_Bit(I2C1,devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT, 1);
}

uint8_t MPU6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
	MPU6050_setMemoryBank(bank,0,0);
	MPU6050_setMemoryStartAddress(address);
    uint8_t chunkSize;
    uint8_t *progBuffer=0;
    uint8_t verifyBuffer[MPU6050_DMP_MEMORY_CHUNK_SIZE];
    uint16_t i;

    //if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    //if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;
        // write the chunk of data as specified
        progBuffer = (uint8_t *)data + i;

        TM_I2C_WriteMulti(I2C1,devAddr,MPU6050_RA_MEM_R_W,progBuffer,(uint16_t)chunkSize);

        //verify data if needed
        //verification code here
        MPU6050_setMemoryBank(bank,0,0);
		MPU6050_setMemoryStartAddress(address);
		TM_I2C_ReadMulti(I2C1,devAddr, MPU6050_RA_MEM_R_W,  verifyBuffer,(uint16_t)chunkSize);
		int m=0;
		for(m = 0; m < chunkSize; m++)
		{

			if(verifyBuffer[m] != progBuffer[m])
				{
				GPIO_SetBits(GPIOD,GPIO_Pin_13|GPIO_Pin_15);
				GPIO_ResetBits(GPIOD,GPIO_Pin_12|GPIO_Pin_14);
				return(0);
				}

		}

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
            if (address == 0) bank++;
            MPU6050_setMemoryBank(bank,0,0);
            MPU6050_setMemoryStartAddress(address);
        }
    }

    return 1;
}

uint8_t MPU6050_writeProgMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
    return MPU6050_writeMemoryBlock(data, dataSize, bank, address);
}

uint8_t MPU6050_writeProgDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {
    return MPU6050_writeDMPConfigurationSet(data, dataSize, 1);
}

void MPU6050_setClockSource(uint8_t source) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
}

void MPU6050_setIntEnabled(uint8_t enabled) {
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_INT_ENABLE, enabled);
}

void MPU6050_setRate(uint8_t rate) {
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_SMPLRT_DIV, rate);
}

void MPU6050_setExternalFrameSync(uint8_t sync) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, sync);
}

void MPU6050_setDLPFMode(uint8_t mode) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, mode);
}

void MPU6050_setFullScaleGyroRange(uint8_t range) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
}

void MPU6050_setDMPConfig1(uint8_t config) {
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_DMP_CFG_1, config);
}

void MPU6050_setDMPConfig2(uint8_t config) {
    TM_I2C_Write(I2C1,devAddr, MPU6050_RA_DMP_CFG_2, config);
}

void MPU6050_setOTPBankValid(uint8_t enabled) {
    TM_I2C_Write_Bit(I2C1,devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, enabled);
}

void MPU6050_setXGyroOffsetTC(int8_t offset) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
}

void MPU6050_setYGyroOffsetTC(int8_t offset) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
}

void MPU6050_setZGyroOffsetTC(int8_t offset) {
    TM_I2C_Write_Bits(I2C1,devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH, offset);
}

void MPU6050_resetFIFO() {
    TM_I2C_Write_Bit(I2C1, devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1);
}

void MPU6050_setMotionDetectionThreshold(uint8_t threshold) {
    TM_I2C_Write(I2C1, devAddr, MPU6050_RA_MOT_THR, threshold);
}

void MPU6050_setZeroMotionDetectionThreshold(uint8_t threshold) {
    TM_I2C_Write(I2C1, devAddr, MPU6050_RA_ZRMOT_THR, threshold);
}

void MPU6050_setMotionDetectionDuration(uint8_t duration) {
    TM_I2C_Write(I2C1, devAddr, MPU6050_RA_MOT_DUR, duration);
}

void MPU6050_setZeroMotionDetectionDuration(uint8_t duration) {
    TM_I2C_Write(I2C1, devAddr, MPU6050_RA_ZRMOT_DUR, duration);
}


void MPU6050_setFIFOEnabled(uint8_t enabled) {
    TM_I2C_Write_Bit(I2C1, devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, enabled);
}

void MPU6050_setDMPEnabled(uint8_t enabled) {
    TM_I2C_Write_Bit(I2C1, devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enabled);
}

void MPU6050_resetDMP() {
    TM_I2C_Write_Bit(I2C1, devAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, 1);
}

uint8_t MPU6050_getIntStatus() {
    ;
    return(TM_I2C_Read(I2C1, devAddr, MPU6050_RA_INT_STATUS));
}

uint8_t MPU6050_dmpInitialize()
{
	TM_I2C_Write_Bit(I2C1,devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, 1);
	delay(3);
	TM_I2C_Write_Bit(I2C1,devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);

	MPU6050_setMemoryBank(0x10, 1, 1);
	MPU6050_setMemoryStartAddress(0x06);
	MPU6050_setMemoryBank(0, 0, 0);

	int8_t xgOffsetTC = MPU6050_getXGyroOffsetTC();
	int8_t ygOffsetTC = MPU6050_getYGyroOffsetTC();
	int8_t zgOffsetTC = MPU6050_getZGyroOffsetTC();

	MPU6050_setSlaveAddress(0, 0x7F);
	MPU6050_setI2CMasterModeEnabled(0);
	MPU6050_setSlaveAddress(0, 0x68);
	MPU6050_resetI2CMaster();
	delay(2);

	GPIO_SetBits(GPIOD,GPIO_Pin_12);

	if (MPU6050_writeProgMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE,0,0))
	{   // write DMP configuration


		if (MPU6050_writeProgDMPConfigurationSet(dmpConfig, MPU6050_DMP_CONFIG_SIZE))
		{
			MPU6050_setClockSource(MPU6050_CLOCK_PLL_ZGYRO);
			MPU6050_setIntEnabled(0x12);
			MPU6050_setRate(4); // 1khz / (1 + 4) = 200 Hz
			MPU6050_setExternalFrameSync(MPU6050_EXT_SYNC_TEMP_OUT_L);
			MPU6050_setDLPFMode(MPU6050_DLPF_BW_42);
			MPU6050_setFullScaleGyroRange(MPU6050_GYRO_FS_2000);
			MPU6050_setDMPConfig1(0x03);
			MPU6050_setDMPConfig2(0x00);
			MPU6050_setOTPBankValid(0);
			MPU6050_setXGyroOffsetTC(xgOffsetTC);
			MPU6050_setYGyroOffsetTC(ygOffsetTC);
			MPU6050_setZGyroOffsetTC(zgOffsetTC);
			//
			//setXGyroOffset(0);
			//setYGyroOffset(0);
			//setZGyroOffset(0);
			uint8_t dmpUpdate[16]={0}, j;
			uint16_t pos = 0;


			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);
			uint16_t fifoCount;
			uint8_t fifoBuffer[128];
			/*MPU6050_resetFIFO();
			fifoCount = MPU6050_getFIFOCount();
			MPU6050_getFIFOBytes(fifoBuffer, fifoCount);
*/
			MPU6050_setMotionDetectionThreshold(2);
			//GPIO_ResetBits(GPIOD,GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);

			MPU6050_setZeroMotionDetectionThreshold(156);
			MPU6050_setMotionDetectionDuration(80);
			MPU6050_setZeroMotionDetectionDuration(0);
			MPU6050_resetFIFO();
			MPU6050_setFIFOEnabled(1);
			MPU6050_setDMPEnabled(1);
			MPU6050_resetDMP();

			GPIO_SetBits(GPIOD,GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_15);



			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);
			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);
			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

			while ((fifoCount = MPU6050_getFIFOCount()) < 3);
			MPU6050_getFIFOBytes(fifoBuffer, fifoCount);
			uint8_t mpuIntStatus = MPU6050_getIntStatus();
			if(mpuIntStatus);

			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_readMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

			while ((fifoCount = MPU6050_getFIFOCount()) < 3);
			MPU6050_getFIFOBytes(fifoBuffer, fifoCount);
			mpuIntStatus = MPU6050_getIntStatus();

			for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = dmpUpdates[pos];
			MPU6050_writeMemoryBlock(dmpUpdate + 3, (uint16_t)dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

			MPU6050_setDMPEnabled(0);
			dmpPacketSize = 42;
			/*if ((dmpPacketBuffer = (uint8_t *)malloc(42)) == 0) {
				return 3; // TODO: proper error code for no memory
			}*/
			MPU6050_resetFIFO();
			MPU6050_getIntStatus();

		}
		else
		{
			return 2; // configuration block loading failed
		}
	}
	else
	{
		return 1; // main binary block loading failed
	}
return 0;
}

int8_t MPU6050_getXGyroOffsetTC() {
    return(TM_I2C_Read_Bits(I2C1, devAddr, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH));
    }
int8_t MPU6050_getYGyroOffsetTC() {
    return(TM_I2C_Read_Bits(I2C1, devAddr, MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH));
    }
int8_t MPU6050_getZGyroOffsetTC() {
    return(TM_I2C_Read_Bits(I2C1, devAddr, MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH));
    }

void MPU6050_setXGyroOffset(int16_t offset) {
    TM_I2C_Write_Word(I2C1,devAddr, MPU6050_RA_XG_OFFS_USRH, offset);
}
void MPU6050_setYGyroOffset(int16_t offset) {
    TM_I2C_Write_Word(I2C1,devAddr, MPU6050_RA_YG_OFFS_USRH, offset);
}
void MPU6050_setZGyroOffset(int16_t offset) {
    TM_I2C_Write_Word(I2C1,devAddr, MPU6050_RA_ZG_OFFS_USRH, offset);
}
void MPU6050_setZAccelOffset(int16_t offset) {
    TM_I2C_Write_Word(I2C1 ,devAddr, MPU6050_RA_ZA_OFFS_H, offset);
}

uint16_t MPU6050_dmpGetFIFOPacketSize() {
    return dmpPacketSize;
}
uint16_t MPU6050_getFIFOCount() {
    TM_I2C_ReadMulti(I2C1 ,devAddr, MPU6050_RA_FIFO_COUNTH, buffer,2);
    return (((uint16_t)buffer[0]) << 8) | buffer[1];
}
void MPU6050_getFIFOBytes(uint8_t *data, uint16_t length) {
    TM_I2C_ReadMulti(I2C1 ,devAddr, MPU6050_RA_FIFO_R_W, data, (uint16_t)length);
}

uint8_t MPU6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize, uint8_t useProgMem) {
    uint8_t *progBuffer = 0;
	uint8_t success, special;
    uint16_t i;
    uint8_t bank, offset, length;
    for (i = 0; i < dataSize;)
    {
        bank = data[i++];
        offset = data[i++];
        length = data[i++];       // write data or perform special action
        if (length > 0)
        {
            // regular block of data to write
            progBuffer = (uint8_t *)data + i;
            success = MPU6050_writeMemoryBlock(progBuffer, length, bank, offset);
            i += length;
        }
        else
        {
            special = data[i++];
            if (special == 0x01)
            {
                TM_I2C_Write(I2C1, devAddr, MPU6050_RA_INT_ENABLE, 0x32);  // single operation
                success = 1;
            }
            else
            {
                success = 0;
            }
        }
        if (!success)
        {
            return 0; // uh oh
        }
    }
    return 1;
}

void MPU6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
    MPU6050_setMemoryBank(bank,0,0);
    MPU6050_setMemoryStartAddress(address);
    uint8_t chunkSize;
    uint16_t i;
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;

        // read the chunk of data as specified
        TM_I2C_ReadMulti(I2C1,devAddr, MPU6050_RA_MEM_R_W, data + i,(uint16_t)chunkSize);

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
            if (address == 0) bank++;
            MPU6050_setMemoryBank(bank,0,0);
            MPU6050_setMemoryStartAddress(address);
        }
    }
}

uint8_t MPU6050_dmpGetQuaternion(int32_t *data, const uint8_t* packet) {
    // TODO: accommodate different arrangements of sent data (ONLY default supported now)
    if (packet == 0) packet = dmpPacketBuffer;
    data[0] = (((uint32_t)packet[0] << 24) | ((uint32_t)packet[1] << 16) | ((uint32_t)packet[2] << 8) | packet[3]);
    data[1] = (((uint32_t)packet[4] << 24) | ((uint32_t)packet[5] << 16) | ((uint32_t)packet[6] << 8) | packet[7]);
    data[2] = (((uint32_t)packet[8] << 24) | ((uint32_t)packet[9] << 16) | ((uint32_t)packet[10] << 8) | packet[11]);
    data[3] = (((uint32_t)packet[12] << 24) | ((uint32_t)packet[13] << 16) | ((uint32_t)packet[14] << 8) | packet[15]);
    return 0;
}

void Get_Data(float* Omega,float *Accel)
	{
		//long long int count;
		//float Anglex=0.0,Angley=0.0,Anglez=0.0;
		//uint32_t Time=0;
		int k=0,i=0;
		uint8_t regadd=0x43;
		uint8_t Data[6];
		uint16_t Data_uint16;
		//float Omega[3],Accel[3];
		//Init_Gyroscope();


		TM_I2C_ReadMulti(I2C1, 0b11010000, regadd,Data,6);
		 for(i=0;i<3;i++)
			 {
				 Data_uint16= ((Data[2*i]<<8)|Data[2*i+1]);		   	//reuniting data
				 int16_t Temp_int16=Data_uint16;
				 int Temp_int=Temp_int16;
				 Temp_int=Temp_int-Offset[i];						//subtracting Offset
				 Omega[i]=(float)Temp_int/131.072;					//dividing by sensitivity(2^16/500) for range (-250 to +250)
			 }

		 regadd=0x3B;
		 for(k=0;k<6;k++)											//reading six resister datas for accelerometer
			 {
				 Data[k]=Rec_data (regadd);
				 regadd++;
			 }

		 for(i=0;i<3;i++)
			 {
				 Data_uint16= ((Data[2*i]<<8)|Data[2*i+1]);		   	//reuniting data
				 int16_t Temp_int16=Data_uint16;
				 int Temp_int=Temp_int16;
				 Temp_int=Temp_int-Offset_accel[i];					//subtracting Offset
				 Accel[i]=(float)Temp_int/16384.0;                  //dividing by the sensitivity
			 }
		 /*
--------------------------------------------------------- to get the present angle------------------------------------------------------------------------------------------
		 //Time=TIM_GetCounter(TIM2);								//taking counter for evaluating Time for one loop
		 //TIM_SetCounter(TIM2,0);									//resetting counter to one
		 Anglex+=(Omega[0])*Time/400000.0;						//multiplying ang. velocity by Time (dividing by period*10) to grt change of Angle in previous loop
		 Angley+=(Omega[1])*Time/400000.0;							//adding change in Angle to previous Angle
		 Anglez+=(Omega[2])*Time/400000.0;
		 */

	}
